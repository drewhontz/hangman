What additional properties did you add to your models and why?
- Game.History
  - During development, I had 2 separate properties: matched_letters and guessed_letters. Matched letters stored letters from guesses that are in the target string while guessed letters are guesses not found in the string. When it came time to implement the get_game_history requirement I rethought my approach and converged the two into one history property. I realized I could compute what was a match and a guess from this string, as well as easily provide an inorder history of guesses.
- Game.Modified
  - I added a timestamp to the last time a game was modified for use in the Cronjob (reminder). My cron job will run once a day, querying games that have not been modified in over 3 days, and notify users of their active game. In order to have some time-based event I realized my models should also have some implementation of tracking time, so I added this new property.

What were some of the trade-offs or struggles you faced when implementing the new game logic?
- Trade-offs:
  - In my first draft, my game.to_form() method returned an 'ASCII art' representation of Hangman. When I deployed it to appspot; the messages were displayed differently than in test and I decided that the time spent maintaining its appearance was far better spent improving the game's logic, so I scrapped my ASCII art representation in exchange for my current to_form() method.
  - My Game model has a won BooleanProperty; I did not want to include this because whether or not a win has been achieved can be computed by comparing the guess history with the target word. However in creating the get_user_rankings method, I found the won property to be useful in computing a user's win differential and decided that it was a simple means to get a user's win count at a low cost
- Struggles:
  - The project was pretty straightforward since I implemented another guessing style game. When I started the project I didn't fully understand what I was about to create so I chose something similar to the example to simplify my work going forward; in hindsight I probably should have implemented a different game as Hangman was so similar. The only real thought intensive/struggle moments I had were thinking of a means to figure out if a Game had been modified in the last 72 hours and working through a few bugs with when to call a game 'over'. For an example, I had to play a number of games before I realized that games with 2 word targets would not end until you guessed the ' ' in between the two words. That was an easy fix, but I did not think through that when I was designing the game over function.
